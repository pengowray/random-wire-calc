<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Random Wire Calculator [VK3PGO]</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        .controls {
            margin-bottom: 20px;
        }
        .checkboxes {
            margin-bottom: 10px;
        }
        .plot {
            width: 100%;
            height: 800px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }
        th {
            background-color: #f2f2f2;
            cursor: pointer;
        }
        footer {
            margin-top: 20px;
            text-align: center;
            font-size: 0.9em;
        }
        .hidden {
            display: none;
        }
    </style>
</head>
<body>

<h1>Random Wire Calculator [VK3PGO]</h1>

<div class="controls">
    <div class="checkboxes">
        <label><input type="checkbox" id="160m" checked> 160m Band</label>
        <label><input type="checkbox" id="80m" checked> 80m Band</label>
        <label><input type="checkbox" id="60m"> 60m Band</label>
        <label><input type="checkbox" id="40m" checked> 40m Band</label>
        <label><input type="checkbox" id="30m" checked> 30m Band</label>
        <label><input type="checkbox" id="20m" checked> 20m Band</label>
        <label><input type="checkbox" id="17m" checked> 17m Band</label>
        <label><input type="checkbox" id="15m" checked> 15m Band</label>
        <label><input type="checkbox" id="12m" checked> 12m Band</label>
        <label><input type="checkbox" id="10m" checked> 10m Band</label>
        <label><input type="checkbox" id="6m"> 6m Band</label>
    </div>
    <label for="velocityFactor">Velocity Factor: </label>
    <input type="text" id="velocityFactor" value="0.95">
    <label for="numResults">Number of Results: </label>
    <input type="number" id="numResults" value="25" min="1">
    <input type="number" id="numResultsPreset" value="13" min="1">
    <label for="minWireM">Min wire length (m): </label>
    <input type="number" id="minWireM" value="7" min="0">
    <label><input type="checkbox" id="hzUnits" onchange="toggledUnit()"> MHz as primary axis</label>
    <label><input type="checkbox" id="logarithmic" checked> Logarithmic</label>
    <br>
    <label for="preset">Preset: 
        <select name="preset" id="preset" onchange="presetUpdated()">
            <option value="calc">No preset (calculate)</option>
            <option value="VE3EED">Jack VE3EED recommendations</option>
            <option value="balundesigns1">Balun Designs recommendations: 160m through 10m</option>
            <option value="balundesigns2">Balun Designs recommendations: limited to 40m through 6m</option>
            <option value="balundesigns3">Balun Designs alternative lengths: 160m through 10m (if all others fail)</option>
            <option value="qrpguys4010">QRPGuys 40m-10m UnUnTenna (9:1)</option>
        </select>
    </label>
    
    
</div>

<div id="plot" class="plot"></div>

<table id="resultsTable">
    <thead>
        <tr>
            <th onclick="sortTable(0)">Pos</th>
            <th onclick="sortTable(1)">Rank</th>
            <th onclick="sortTable(0)">Length (m)</th>
            <th onclick="sortTable(0)">Length (ft in)</th>
            <th onclick="sortTable(4)">Conflicts</th>
        </tr>
    </thead>
    <tbody></tbody>
</table>

<footer>
    <p>Long-wire calculator. Developed by Pengo VK3PGO. Inspired by Jack <a onclick="easterEgg()">VE3EED</a> (SK). This work is licensed under a Creative Commons Attribution 4.0 International License or MIT. | Built with Plotly.js | <a href="https://github.com/pengowray/random-wire-calc">Readme and details on github</a></p>
    <p>
    <a href="https://github.com/pengowray/random-wire-calc">
      <img src="https://img.shields.io/badge/View%20on-GitHub-brightgreen" alt="View on GitHub">
    </a>
    </p>
</footer>

<script>
const speedOfLight = 299792458;

// https://www.balundesigns.com/content/Wire%20Lengths%20for%204%20and%209-1%20ununs.pdf [date?] found via https://youtu.be/xfqlun3bdI0?t=86 [2017] "53 59 72 88.5 98.5 124.5 135 146 162 175"

const presets = {
    "VE3EED": {
        name : "Jack VE3EED recommendations",
        feet:  "29  35.5  41  58  71  84  107  119  148  203  347  407  423",
        count: 13
    },
    "balundesigns1": {
        name: "Balun Designs recommendations: 160m through 10m",
        feet: "53 59 72 88.5 98.5 124.5 146 162 175",
        count: 9
    },
    "balundesigns2": {
        name: "Balun Designs recommendations: limited to 40m through 6m",
        feet: "36 44 49",
        count: 3
    },
    "balundesigns3": {
        // 160m through 10m (alternative lengths if all others fail)
        name: "Balun Designs alternative lengths: 160m through 10m (if all others fail)",
        feet:  "58 71 84 107 119 148 203",
        count: 7
    },
    "qrpguys4010": {
        name: "QRPGuys 40m-10m UnUnTenna 9:1",
        feet: "41 35.5 29",
        // counterpoise: 
    },
    // aliexpress special includes 16.5m antenna, 10m ground
};

for (const p in presets) {
    presets[p].count = presets[p].feet.split(' ').filter(num => num).length;
}


var preset = presets['VE3EED'];

const maxDisplayFreq = 1.6; // gets vf applied to it
const maxAllowedWireLength = 200;
const vfc = 1.0; // no velocity factor; constant vf for display; for when vf not needed or already calculated

const frequencyRanges = {
    "160m": [1.8, 2.0],
    "80m": [3.5, 4.0],
    "60m": [5.3, 5.4],
    "40m": [7.0, 7.3],
    "30m": [10.1, 10.15],
    "20m": [14.0, 14.35],
    "17m": [18.068, 18.168],
    "15m": [21.0, 21.45],
    "12m": [24.89, 24.99],
    "10m": [28.0, 29.7],
    "6m": [50.0, 54.0]
};

const factors = [
    { value: 1/2, penalty: 10, type: 'fraction', valtext: '0.5' }, // '½'
    //{ value: 1/3, penalty: 3, type: 'fraction', valtext: '⅓' },
    { value: 1/4, penalty: 9, type: 'fraction' }, // '¼' '1/4'
    { value: 1/8, penalty: 3, type: 'fraction', valtext: '1/8' }, // , valtext: '⅛' 
    { value: 1/16, penalty: 2, type: 'fraction', valtext: '1/16' }, 
    //{ value: 3/4, penalty: 8, type: 'fraction' },
    //{ value: 1/8, penalty: 3, type: 'fraction' },
    //{ value: 5/8, penalty: 6, type: 'fraction' },
    //{ value: 2/3, penalty: 5, type: 'fraction' },
    //{ value: 1/5, penalty: 4, type: 'fraction' },
    //{ value: 2/5, penalty: 4, type: 'fraction' },
    { value: 1, penalty: 7, type: 'whole', highlight: true },
    { value: 2, penalty: 6, type: 'multiple' },
    { value: 3, penalty: 5, type: 'multiple' },
    { value: 4, penalty: 4, type: 'multiple' },
    { value: 5, penalty: 3, type: 'multiple' },
    { value: 6, penalty: 2, type: 'multiple' },
    { value: 7, penalty: 2, type: 'multiple' },
    { value: 8, penalty: 1, type: 'multiple' },
    { value: 9, penalty: 1, type: 'multiple' },
    { value: 10, penalty: 1, type: 'multiple' },
    { value: 11, penalty: 0.6, type: 'multiple' },
    { value: 12, penalty: 0.6, type: 'multiple' },
    { value: 13, penalty: 0.6, type: 'multiple' },
    { value: 14, penalty: 0.6, type: 'multiple' },
    { value: 15, penalty: 0.6, type: 'multiple' },
    { value: 16, penalty: 0.6, type: 'multiple' },
    { value: 17, penalty: 0.6, type: 'multiple' },
    { value: 18, penalty: 0.6, type: 'multiple' },
    { value: 19, penalty: 0.6, type: 'multiple' },
    { value: 20, penalty: 0.6, type: 'multiple' }
];
//set valtext for all
for (let factor of factors) {
    if (!factor.valtext) {
        factor.valtext = `${factor.type === 'fraction' ? factor.value.toFixed(2) : factor.value.toFixed(0)}`;
    }
}

//let currentUnit = 'meters';
let currentUnit = document.getElementById('hzUnits').checked ? 'hertz' : 'meters';
let presetMode = false;

function calculateWavelength(freq, vf) {
    return (speedOfLight * vf) / (freq * 1e6);
}

function calculateFrequency(length, vf) {
    return (speedOfLight * vf) / (length * 1e6);
}

function findConflicts(length, selectedBands, factors, vf) {
    const conflicts = new Set();
    for (const [band, [startFreq, endFreq]] of Object.entries(frequencyRanges)) {
        if (selectedBands.some(([selectedBand]) => selectedBand === band)) {
            const minElectricalWavelength = calculateWavelength(endFreq, vf);
            const maxElectricalWavelength = calculateWavelength(startFreq, vf);
            for (const { value, type, penalty, valtext } of factors) {
                const minLength = minElectricalWavelength * value;
                const maxLength = maxElectricalWavelength * value;
                if (length >= minLength && length <= maxLength) { //  && maxWavelength * value <= calculateWavelength(maxDisplayFreq, vf)
                    const startFreqMHZ = (endFreq * value).toFixed(2);
                    const endFreqMHZ = (startFreq * value).toFixed(2);
                    conflicts.add( {text: `${band} ${valtext}λ`, value, type, penalty, valtext } );
                }
            }
        }
    }
    return Array.from(conflicts);
}

function calculate() {
    const vf = parseFloat(document.getElementById('velocityFactor').value);
    const numResultsInput = document.getElementById('numResults');
    const numResultsInputPreset = document.getElementById('numResultsPreset');
    const logarithmic = document.getElementById('logarithmic').checked;
    const selectedBands = Object.entries(frequencyRanges).filter(([band]) => document.getElementById(band).checked);
    const minWireLen = parseFloat(document.getElementById('minWireM').value);

    const presetChoice = document.getElementById('preset').value;
    const wasPreset = numResultsInputPreset.classList.contains('hidden');
    let numResults = 10;

    presetMode = presetChoice === 'calc' ? false : true;
    minWireM.disabled = presetMode;

    if (presetMode) {
        preset = presets[presetChoice];
        numResultsInputPreset.value = preset.count;
        numResultsInputPreset.disabled = true;
        numResultsInput.classList.add('hidden');
        numResultsInputPreset.classList.remove('hidden');
        numResults = preset.count;

    } else {
        numResultsInputPreset.classList.add('hidden');
        numResultsInput.classList.remove('hidden');
        numResults = parseInt(numResultsInput.value);
    }

    if (presetMode) {
        
        //const ve3eedLengthsFt = presets.split(' ').filter(num => num).map(Number);
        //var presetChoice = document.getElementById('preset').value;
        //var preset = presets[presetChoice].feet;
        const presetLensFt = preset.feet.split(' ').filter(num => num);
        
        const scoredPresetLens = presetLensFt.map((ft, index) => {
            const length = Number(ft) * 0.3048;
            const conflicts = findConflicts(length, selectedBands, factors, vf);
            let score = 0;
            conflicts.forEach(conflict => {
                score -= conflict.penalty;
            });
            return { length, conflicts, score, originalIndex: index + 1, ft };
        });

        scoredPresetLens.sort((a, b) => b.score - a.score);

        const results = scoredPresetLens.map((result, index) => {
            const length = result.length;
            return {
                pos: result.originalIndex, // lengthToPosMap[result.mid],
                rank: index + 1,
                length: `${length.toFixed(3)} m`,
                size: `${result.ft} ft`,
                conflicts: result.conflicts.map(o => o.text).join(', '),
                score: result.score,
                originalIndex: result.originalIndex
            };
        });

        plotResults(selectedBands, results, vf, logarithmic, true);

        const tableBody = document.getElementById('resultsTable').querySelector('tbody');
        tableBody.innerHTML = '';
        results.forEach((result) => {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${result.pos}</td>
                <td>${result.rank}</td>
                <td>${result.length}</td>
                <td>${result.size}</td>
                <td>${result.conflicts.length ? result.conflicts : '—'}</td>
            `;
            tableBody.appendChild(row);
        });
    } else {
        const avoidSet = new Set();
        for (const [band, [startFreq, endFreq]] of selectedBands) {
            for (const freq of [startFreq, endFreq]) {
                const wavelength = calculateWavelength(freq, vf);
                for (const { value } of factors) {
                    const length = Math.round(wavelength * value * 1000) / 1000;
                    //if (length <= calculateWavelength(maxDisplayFreq, vf)) {
                        avoidSet.add(length);
                    //}
                }
            }
        }

        const avoidList = Array.from(avoidSet).sort((a, b) => a - b);
        const midPoints = [];
        const bandwidths = [];

        for (let i = 0; i < avoidList.length - 1; i++) {
            const midPoint = (avoidList[i] + avoidList[i + 1]) / 2;
            const bandwidth = avoidList[i + 1] - avoidList[i];
            if (midPoint < minWireLen) continue;
            if (midPoint >= maxAllowedWireLength) continue;
            midPoints.push(midPoint);
            bandwidths.push(bandwidth);
        }

        const scoredMidPoints = midPoints.map((mid, index) => {
            let score = bandwidths[index] / mid;
            const conflicts = findConflicts(mid, selectedBands, factors, vf);
            const debugInfo = [];
            debugInfo.push({ score });
            conflicts.forEach(conflict => {
                score -= conflict.penalty;
                debugInfo.push({ conflict });
            });
            console.log(`Midpoint: ${mid.toFixed(3)} m, Score: ${score.toFixed(2)}, Debug Info:`, debugInfo);
            return { mid, bandwidth: bandwidths[index], score, conflicts, originalIndex: index + 1 };
        });

        scoredMidPoints.sort((a, b) => b.score - a.score);
        const topResults = scoredMidPoints.slice(0, numResults);

        // Create a mapping of the sorted lengths to their position (pos)
        const lengthSortedResults = [...topResults].sort((a, b) => a.mid - b.mid);
        const lengthToPosMap = lengthSortedResults.reduce((acc, result, idx) => {
            acc[result.mid] = idx + 1;
            return acc;
        }, {});

        const results = topResults.map((result, index) => {
            const length = result.mid;
            const conflicts = findConflicts(length, selectedBands, factors, vf);
            const feet = Math.floor(length * 3.28084);
            const inches = Math.floor((length * 3.28084 - feet) * 12);
            return {
                pos: lengthToPosMap[result.mid],
                rank: index + 1,
                length: `${length.toFixed(3)} m`,
                size: `${feet} ft ${inches} in`,
                conflicts: conflicts.map(o => o.text).join(', '),
                score: result.score.toFixed(2),
                originalIndex: result.originalIndex
            };
        });

        plotResults(selectedBands, results, vf, logarithmic, false);

        const tableBody = document.getElementById('resultsTable').querySelector('tbody');
        tableBody.innerHTML = '';
        results.forEach((result) => {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${result.pos}</td>
                <td>${result.rank}</td>
                <td>${result.length}</td>
                <td>${result.size}</td>
                <td>${result.conflicts.length ? result.conflicts : '—'}</td>
            `;
            tableBody.appendChild(row);
        });
    }

    console.log('Good lengths with conflicts:', typeof results !== 'undefined' ? results : 'results is not defined');

    sortTable(0);
}

function plotResults(selectedBands, results, vf, logarithmic, ve3eedMode) {
    const traceData = [];
    selectedBands.forEach(([band, [startFreq, endFreq]], index) => {
        // electrical length in wire
        const minWavelength = calculateWavelength(endFreq, vf);
        const maxWavelength = calculateWavelength(startFreq, vf);
        // wavelength in space
        const minWavelengthInSpace = calculateWavelength(endFreq, vfc);
        const maxWavelengthInSpace = calculateWavelength(startFreq, vfc);
        
        for (const { value, type, penalty, highlight, valtext } of factors) {
            const adjustedFreqMin = startFreq / value;
            const adjustedFreqMax = endFreq / value;
            const xValues = currentUnit === 'meters' ? 
                            [minWavelengthInSpace * value, maxWavelengthInSpace * value] :
                            [adjustedFreqMin, adjustedFreqMax];
            const col = highlight ? '#2C3E50' : value > 1 ? '#E74C3C' : '#3498AB';
            const lambda = (value == 1) ? '' : ` ${valtext}λ`
            const hovertext = `<b>${band} band${lambda}</b><br>${(adjustedFreqMin).toFixed(2)} to ${(adjustedFreqMax).toFixed(2)} MHz <br><i>λ=${(minWavelengthInSpace * value).toFixed(3)} to ${(maxWavelengthInSpace * value).toFixed(3)} m</i> <br><b>Wire lengths</b> (vf ${vf.toFixed(2)}):<br>${(minWavelength * value).toFixed(3)} – ${(maxWavelength * value).toFixed(3)} m`;

            if ((maxWavelength * value <= calculateFrequency(maxDisplayFreq, vf)) || minWavelength * value <= calculateFrequency(maxDisplayFreq, vf)) { 
                traceData.push({
                    x: xValues,
                    y: [index + 1, index + 1],
                    type: 'scatter',
                    mode: 'lines+markers',
                    line: { shape: 'linear', width: 35, color: col },
                    marker: { // marker is a vertical line, just to make boxes visible when too thin to be rendered
                        size: 20,
                        symbol: 'line-ns', // vert line
                        line: { color : col, width: 1 },
                        //color: col, // (no fill needed for line-ns)
                    },
                    //name: band,
                    name: `${band} ${valtext}`,
                    hovertemplate: [hovertext, hovertext]
                });
            }
        }
    });

    const bestData = results.map((result) => {
        const electricalLength = parseFloat(result.length) / vf;
        const freq = calculateFrequency(parseFloat(result.length), vf);
        const xValue = currentUnit === 'meters' ?  electricalLength : freq;
        //const labelText = ve3eedMode ? `#${result.pos}: ${result.length} (${result.size})` : `#${result.pos}: ${result.length} (${result.size}) Rank:${result.rank}`;
        var intersects = '';
        if (result.conflicts) intersects = `<br><br><b>Intersects:</b><br> ${result.conflicts}`;
        const nameText = `Wire #${result.pos}`;
        const labelText = `Wire #${result.pos} <br><br><b>Physical:</b><br>${result.length}<br>${result.size}<br><br><b>Electrical:</b><br>${freq.toFixed(2)} MHz<br><i>λ=${electricalLength.toFixed(3)} m</i> ${intersects}`;
        //const col = ve3eedMode ? '#AD32AD' : '#22AD22';
        const col = result.conflicts ? '#aaaaaa' : '#22AD22';
        const symbol = result.conflicts ? 'circle-open' : 'circle-closed';

        return [
            {
                x: [xValue],
                y: [selectedBands.length + 1],
                type: 'scatter',
                mode: 'markers',
                marker: { color: col, size: 10, symbol },
                name: nameText,
                //text: [labelText],
                hovertemplate: [labelText] // hides redundant "Wire" heading you get with "text"
            },
            {
                x: [xValue],
                y: [0],
                type: 'scatter',
                mode: 'markers',
                marker: { color: col, size: 2, symbol: 'circle-open' },
                name: nameText,
                //text: [labelText],
                hoverinfo: 'skip'
            },
            {
                x: [xValue, xValue],
                y: [0, selectedBands.length + 1],
                type: 'scatter',
                mode: 'lines',
                line: { color: col, width: 2, dash: 'dash' },
                showlegend: false,
                hoverinfo: 'skip'
            }
        ];
    }).flat();

    const xrange0 = 2;
    const xrange1 = 180;
    var xrangeA = [];
    var xrangeB = []; // second xaxis 
    var titleA = '';
    var titleB = '';
    if (currentUnit === 'meters') {
        xrangeA = [xrange0, xrange1]
        xrangeB = [calculateFrequency(xrange0, vfc), calculateFrequency(xrange1, vfc)];
    } else {
        xrangeA = [calculateFrequency(xrange1, vfc), calculateFrequency(xrange0, vfc)];
        xrangeB = [xrange1, xrange0]
    }
    if (logarithmic) {
        xrangeA = [Math.log10(xrangeA[0]), Math.log10(xrangeA[1])];
        xrangeB = [Math.log10(xrangeB[0]), Math.log10(xrangeB[1])];        
    }
    console.log({xrangeA, xrangeB});
    const dummyTrace = {
        x: [xrangeB[0], xrangeB[1]],  // Example data range
        y: [selectedBands.length + 1, selectedBands.length + 1],  // Example position
        type: 'scatter',
        mode: 'lines',
        line: { color: 'rgba(0,0,0,0)' },  // Invisible line
        xaxis: 'x2',
        showlegend: false,
        hoverinfo: 'none'
    };
    
    const layout = {
        xaxis: {
            title: currentUnit === 'meters' ? 'Wavelength (meters)' : 'Frequency (MHz)',
            type: logarithmic ? 'log' : 'linear',
            range: xrangeA, 
            side: 'bottom',
        },
        xaxis2: {
            title: currentUnit !== 'meters' ? 'Wavelength (meters)' : 'Frequency (MHz)',
            type: logarithmic ? 'log' : 'linear',
            range: xrangeB, 
            side: 'top',
            overlaying: 'x',
            anchor: 'y' 
        },

        yaxis: {
            title: 'Bands',
            tickvals: Array.from({ length: selectedBands.length }, (_, i) => i + 1).concat([selectedBands.length + 1, 0]),
            ticktext: selectedBands.map(([band]) => band).concat(['Wire', 'Wire']),
            showticklabels: true,
            range: [0, selectedBands.length + 2]
        },
        showlegend: false
        
    };

    Plotly.newPlot('plot', [...bestData, ...traceData, dummyTrace], layout);
    //Plotly.newPlot('plot', [...bestData, ...traceData], layout);
}

function toggledUnit() {
    //currentUnit = currentUnit === 'meters' ? 'hertz' : 'meters';
    currentUnit = document.getElementById('hzUnits').checked ? 'hertz' : 'meters';
    
    calculate();
}

function sortTable(columnIndex) {
    const table = document.getElementById('resultsTable');
    const rows = Array.from(table.rows).slice(1);
    const sortedRows = rows.sort((a, b) => {
        const cellA = a.cells[columnIndex].innerText;
        const cellB = b.cells[columnIndex].innerText;
        if (columnIndex === 0 || columnIndex === 1 || columnIndex === 2) {  // Numeric columns
            return parseFloat(cellA) - parseFloat(cellB);
        }
        return cellA.localeCompare(cellB);
    });
    const tableBody = table.querySelector('tbody');
    tableBody.innerHTML = '';
    sortedRows.forEach(row => tableBody.appendChild(row));
}

function presetUpdated() {
    calculate();
}

document.getElementById('logarithmic').addEventListener('change', calculate);
document.querySelectorAll('.checkboxes input').forEach(checkbox => checkbox.addEventListener('change', calculate));
document.getElementById('velocityFactor').addEventListener('keypress', (event) => {
    if (event.key === 'Enter') {
        calculate();
    }
});
document.getElementById('numResults').addEventListener('input', (event) => {
    calculate();
});
document.getElementById('minWireM').addEventListener('input', (event) => {
    calculate();
});
document.addEventListener('DOMContentLoaded', calculate);

</script>

</body>
</html>
